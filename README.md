# Задание 1

**Условие:**

>На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 
```python
def isEven(value):
  return value % 2 == 0
```
**Решение:**

[Исходный код](https://github.com/AlexRybkin-keramzit/LestaGames/blob/master/Task1/isEven.py)
```python
def isEvenNew(value):
    return value & 1 == 0
```
Функция представленная в примере проще для понимания, однако работает медленне функции из решения, т.к. последняя
работает на более низкоуровневых процессорных операциях.

# Задание 2

**Условие:**

>На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.
>
>Оценивается:
>
>1.Полнота и качество реализации
>
>2.Оформление кода
>
>3.Наличие сравнения и пояснения по быстродействию

**Решение:**
[Исходный код](https://github.com/AlexRybkin-keramzit/LestaGames/tree/master/Task2)

- Первый вариант CyclicBuffer я реализовал основываясь на встроенных функциях языка Python. Данный вариант считаю предпочтительным, т.к. данная реализация первой приходит на ум, выглядит компактной и ясна изначально.
- Второй вариант IndexBuffer реализован через отслеживание индекса последнего элемента, и основные операции основаны на его реализации. Данный вариант мне нравится меньше из-за:
1. необходимости вводить новый функционал в виде индекса,
2. громосткий вид, в сравнении с первым вариантом, из-за чего реализация тяжелее воспринимается,
3. массив всегда полон, а значит памяти используется больше, чем в первом варианте, который не требует полноты массива.

Однако из-за отсутсвия использования встроенных функций вторая реализация меньше нагружает интерпритатор, а следовательно быстродейственнее.

# Задание 3

**Условие:**

>На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

**Решение:**
[Исходный код](https://github.com/AlexRybkin-keramzit/LestaGames/blob/master/Task3/QuickSort.py)

Данный вариант сортировки имеет сложность:
- O(n∗log(n))  в среднем и лучшем случае,
- O(n^2)  в худшем случае.

Приведенный алгоритм не создает дополнительные контейнеры данных, а сортирует последовательность в имеющемся массиве.  
Подобный метод является сортировкой по-умолчанию на языке java, а также на данном методе реализована функция qsort() на 
языке C. 
